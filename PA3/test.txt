 HTTP Status Codes Implementation Analysis


  Correctly Implemented Status Codes:


  Issues and Missing Error Responses:

  3. Inconsistent Content-Length Headers:
    - Some responses include Content-Length (line 521) while others don't (line 534)
    - Missing Content-Length can cause problems with persistent connections
  4. Socket-Level Error Handling:
    - Socket errors in server connections don't always send proper HTTP error codes
    - Connection failures sometimes close socket without sending error response
  5. Malformed Responses:
    - Line 131-132: Uses asprintf(&send_req, "%s 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nBlocked", header->http_version_str);
    - This is missing a space after HTTP version - should be HTTP/1.1 403 not HTTP/1.1403



  5. Implement consistent logging of error conditions:


  These improvements will make your proxy more robust and standards-compliant, providing clearer error information to clients and better
  diagnostic capabilities.

> think aagain, deep think, make detailed text with all the fiel ane line number with keeping all the errors in mind and what errors im 
  sending to client if those are not matching let me know nad if im missing some error let me know if you see somthing wierd let me know

✻ Thinking…

  Let me conduct a deeper, more detailed analysis focusing on specific files, line numbers, and error handling across the entire 
  codebase.

  Main Request Handler Analysis (src/handle_req.c)

  Error Handling in parse_request_line_thread_safe() calls:

  - Line 514-526: Handles parsing errors, but uses a generic 404 response for all parser errors:
  if (parse_request_line_thread_safe(recieved_buf, &header) < 0) {
      printf(RED "[-] (%d) HTTP Parsing Error:\n"
             "[-] Error code: 0x%02X\n" RESET, 
             gettid(), header.parser_error);
      char *send_req = "HTTP/1.0 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: 19\r\n\r\nSomthing went wrong";
      if (send(sd->client_sock_fd, send_req, strlen(send_req), 0) < 0) {
          fprintf(stderr, RED "[-] (%d) send-server failed for server %d\n" RESET, gettid(), errno);
      }
      goto cleanup;
  }
  Issue: Doesn't differentiate between different parser errors. Parser can detect BAD_REQ, METHOD_NOT_ALLOWED, PARSE_ERROR_INVALID_URI, 
  etc., but they all result in a generic 404 response.

  Blocklist Handling:

  - Line 529-541: Correctly sends 403 Forbidden for blocked domains:
  if (is_blocked(NULL, header.hostname_str)) {
      printf(RED "[-] (%d) ACCESS DENIED: Domain is in blocklist\n"
             "[-] Blocked domain: %s\n"RESET, 
             gettid(), header.hostname_str);
      char *send_req = "HTTP/1.0 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nBlocked";
      if (send(sd->client_sock_fd, send_req, strlen(send_req), 0) < 0) {
          fprintf(stderr, RED "[-] (%d) send-server failed for server %d\n" RESET, gettid(), errno);
          goto cleanup;
      }
      goto cleanup;
  }
  Issue: Hardcoded HTTP/1.0 version instead of using header.http_version_str.

  Server Connection Issues in if_not_cached():

  - Line 125-141: getaddrinfo() error handling sends 403 Forbidden:
  if ((getaddrinfo(header->hostname_str, header->hostname_port_str, &hints, &servinfo)) < 0) {
      fprintf(stderr, RED "getaddrinfo\n" RESET);
      if(sd->client_sock_fd > 0 && send_to_client){
          char *send_req;
          asprintf(&send_req, "%s 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nBlocked", header->http_version_str);
          if ((send(sd->client_sock_fd, send_req, strlen(send_req), 0) < 0)) {
              fprintf(stderr, RED "[-] (%d) send-server failed for server %d\n" RESET, gettid(), errno);
          }
          free(send_req);
      }
      return -1;
  }
  Issues:
  1. Missing a space between version and status code %s 403 should be %s 403
  2. Using 403 Forbidden for a name resolution error doesn't accurately describe the issue (should be 502 Bad Gateway or 504 Gateway 
  Timeout)

  - Line 163-176: Connection failure sends 403 Forbidden:
  if (temp == NULL) {
      if(sd->client_sock_fd > 0 && send_to_client){
          char *send_req;
          asprintf(&send_req, "%s 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nBlocked", header->http_version_str);
          if ((send(sd->client_sock_fd, send_req, strlen(send_req), 0) < 0)) {
              fprintf(stderr, RED "[-] (%d) send-server failed for server %d\n" RESET, gettid(), errno);
          }
      }
      close(sockfd);
      return -1;
  }
  Same issues as above.

  - Line 203-208: Send failure to server doesn't return an error to the client:
  if (send(sockfd, send_req, strlen(send_req), MSG_NOSIGNAL) < 0) {
      fprintf(stderr, RED "[-] (%d) send failed for server %d \n" RESET, gettid(), errno);
      close(sockfd);
      return -1;
  }
  Issue: No error response is sent to client.

  Loop proxy prevention in if_not_cached():

  - Line 111-121: Prevents proxy itself from being proxied, but confusing error message
  if(strcmp(header->hostname_port_str, "8080") == 0 && ((strcmp(header->hostname_str, "localhost") == 0 || strcmp(header->hostname_str, 
  "127.0.1.1") == 0)) && send_to_client) {
      char *send_req;
      asprintf(&send_req, "%s 404 Not Found\r\nContent-Type: text/plain\r\n\r\n cannot req proxy", header->http_version_str);
      if (send(sd->client_sock_fd, send_req, strlen(send_req), 0) < 0) {
          fprintf(stderr, RED "[-] (%d) send-server failed for server %d\n" RESET, gettid(), errno);
      }
      free(send_req);
      return -1;
  }
  Issues:
  1. No Content-Length header
  2. Using 404 Not Found isn't accurate (should be more like 403 Forbidden or 508 Loop Detected)

  Timeout Handling:

  - Line 475-482: Connection timeout doesn't send any HTTP response to the client:
  else if (select_status == 0) {
      printf(YEL "\n[-] (%d) CONNECTION TIMEOUT:\n"
             "[-] Client connection idle for %d seconds\n"
             "------------------------------------------------------------\n" RESET, 
             gettid(), TIMEOUT_HTTP_SEC);
      break;
  }
  Issue: Client doesn't receive any indication that the connection timed out.

  Parser Error Handling (src/parser.c)

  Method Not Allowed:

  - Line 187-191: Detects method not allowed but doesn't specify how to handle it:
  else if(!valid_method){
      printf(RED"[-] (%d)no valid method \n"RESET, gettid());
      header->parser_error |= METHOD_NOT_ALLOWED;
      return SOME_ERROR;
  }
  Issue: Later in handle_req.c this gets treated as a generic 404 error.

  HTTP Version Not Supported:

  - Line 268-272: Detects unsupported HTTP version:
  default:
      printf(RED"[-] (%d)somthing wrong in version\n"RESET, gettid());
      header->parser_error |= VERSION_NOT_SUPPORTED;
      return SOME_ERROR;
  Issue: Later in handle_req.c this gets treated as a generic 404 error rather than proper 505 HTTP Version Not Supported.

  URI Path Traversal:

  - Line 214-220: Detects path traversal attempts:
  if (strstr(uri, "..") != NULL) {
      printf(RED"[-] (%d)uri has .. \n"RESET, gettid());
      header->parser_error |= FORBIDDEN;
      return SOME_ERROR;
  }
  Issue: Sets FORBIDDEN flag, but in handle_req.c this gets treated as a generic 404 error.

  Bad Request:

  - Multiple instances of setting header->parser_error |= BAD_REQ, but all treated as 404 errors in handle_req.c.

  Cache-Related Errors (src/cache.c)

  - Line 268-270: Expired cache entries don't trigger a specific error:
  printf(YEL"[+] (%d) File is %lu sec long, (Need to fetch newer one) (>%ld)!\n"RESET, gettid(), current_time - entry->timestamp, 
  timeout);
  pthread_mutex_unlock(&table_to_use->lock);
  remove(entire_filename);
  Issue: No specific error handling for cache-related issues.

  Missing HTTP Status Codes

  Based on this deeper analysis, here are the HTTP status codes that should be implemented but are missing or improperly handled:

  1. 400 Bad Request: Detected in parser.c but sent as 404 Not Found
  2. 405 Method Not Allowed: Detected in parser.c but sent as 404 Not Found
  3. 408 Request Timeout: Not sent when connection times out
  4. 500 Internal Server Error: Not implemented for internal proxy errors
  5. 502 Bad Gateway: Not sent when upstream server is unreachable (using 403 instead)
  6. 504 Gateway Timeout: Not sent when upstream server doesn't respond in time
  7. 505 HTTP Version Not Supported: Detected in parser.c but sent as 404 Not Found
  8. 508 Loop Detected: Should be used instead of 404 for proxy loop prevention

● Comprehensive Error Handling Analysis in Proxy Implementation

  1. Parser Error Handling Issues (src/parser.c)

  HTTP Method Validation (Lines 164-191)

  - ISSUE: Detects invalid methods but no accurate HTTP status code is returned
  - When method != GET (Line 168-177): header->parser_error |= METHOD_NOT_ALLOWED
  - Should return 405 Method Not Allowed with Allow header listing supported methods

  HTTP Version Validation (Lines 244-272)

  - ISSUE: Detects invalid HTTP versions but sends wrong error
  - Line 270: header->parser_error |= VERSION_NOT_SUPPORTED
  - Should return 505 HTTP Version Not Supported instead of getting handled as 404

  URI Path Traversal Detection (Lines 214-220)

  - ISSUE: Correctly detects path traversal but wrong response
  - Line 218: header->parser_error |= FORBIDDEN
  - Should send 403 Forbidden but gets treated as 404

  Invalid HTTP Request Format (Multiple locations)

  - Sets header->parser_error |= BAD_REQ but all treated as 404
  - Should return 400 Bad Request with descriptive message

  2. Error Response Generation (src/handle_req.c)

  Generic Parser Error Response (Lines 514-526)

  if (parse_request_line_thread_safe(recieved_buf, &header) < 0) {
      // ...
      char *send_req = "HTTP/1.0 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: 19\r\n\r\nSomthing went wrong";
      // ...
  }
  - CRITICAL ISSUE: All parser errors (405, 400, 505) incorrectly return 404
  - Hardcoded HTTP/1.0 ignores client's requested version
  - "Somthing went wrong" has typo and doesn't explain the actual error

  Blocklist Error Response (Lines 529-541)

  char *send_req = "HTTP/1.0 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nBlocked";
  - Correctly uses 403 Forbidden
  - ISSUE: Hardcoded HTTP/1.0 instead of header.http_version_str
  - Missing Content-Length header

  3. Network Error Handling (src/handle_req.c)

  DNS Resolution Failures (Lines 125-141)

  asprintf(&send_req, "%s 403 Forbidden\r\nContent-Type: text/plain\r\n\r\nBlocked", header->http_version_str);
  - ISSUE: Missing space after HTTP version (%s 403 should be %s 403)
  - WRONG STATUS CODE: Uses 403 Forbidden for DNS failures
  - Should use 502 Bad Gateway or 504 Gateway Timeout

  Connection Failures (Lines 163-176)

  - Same issues as DNS failures
  - Incorrectly uses 403 Forbidden instead of 502 Bad Gateway

  Send Failures (Lines 203-208)

  - No error response sent to client when proxy can't send to server
  - Should return 502 Bad Gateway

  Proxy Loop Prevention (Lines 111-121)

  asprintf(&send_req, "%s 404 Not Found\r\nContent-Type: text/plain\r\n\r\n cannot req proxy", header->http_version_str);
  - Uses 404 Not Found for proxy loop
  - Should use 508 Loop Detected or 403 Forbidden
  - Missing Content-Length header

  Timeout Handling (Lines 475-482)

  - No HTTP response sent when connection times out
  - Should send 408 Request Timeout

  4. Missing Status Codes

  1. 400 Bad Request: Detected but sent as 404
  2. 405 Method Not Allowed: Detected but sent as 404
  3. 408 Request Timeout: Not implemented
  4. 500 Internal Server Error: Not implemented for internal errors
  5. 502 Bad Gateway: Not implemented (using 403 instead)
  6. 504 Gateway Timeout: Not implemented
  7. 505 HTTP Version Not Supported: Detected but sent as 404
  8. 508 Loop Detected: Not implemented (using 404)

  5. Inconsistent Response Format

  1. Some responses include Content-Length (line 521) while others don't (line 534)
  2. Missing space after HTTP version in some responses
  3. Inconsistent HTTP version in responses (hardcoded vs. client's version)
  4. Non-descriptive error messages

  Recommended Fix: Create a standardized error response function

  void send_error_response(int client_fd, const char *http_version, 
                           int status_code, const char *message) {
      const char *status_text = get_status_text(status_code);
      int length = strlen(message);
      char *response;

      asprintf(&response, "%s %d %s\r\n"
               "Content-Type: text/plain\r\n"
               "Content-Length: %d\r\n\r\n%s",
               http_version, status_code, status_text, length, message);

      send(client_fd, response, strlen(response), 0);
      free(response);
  }